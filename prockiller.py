import ctypes

uhandle = ctypes.WinDLL("User32.dll")  #This DLL is loaded to use GetWindowThreadProcessID
khandle = ctypes.WinDLL("Kernel32.dll") #This DLL is loaded to use GetLastError(), OpenProcess(), TerminateProcess()

PROCESS_ALL_ACCESS = ( 0x000F0000 | 0x00100000 | 0xFFF )  #shortcut to set PROCESS_ALL_ACCESS privilege to be assigned to dwDesiredAccess
dwDesiredAccess = PROCESS_ALL_ACCESS 
bInheritHandle = False  #Takes boolean value 

lpWindowName = ctypes.c_char_p(input("Enter window name to kill ").encode('UTF-8'))  #lpWindowName parameter in FindWindowA is of type LPCTSTR which means it's a pointer and FindWindowA is of type ANSI. to represent pointer type (ie lp) we use "ctypes.c_char_p" and we encode it in ANSI using encode('UTF-8')
#print(lpWindowName) if we print lpWindowName here, it will show us the pointer address of the windows name provided above. for Eg: Task Manager pointer address

findwindow = uhandle.FindWindowA(None, lpWindowName) #Calling FindWindowA, note that we simply passed lpClassName value as None so it finds any window whose title matches the lpWindowName parameter. ie whatever we provide as input in the previous line
#lpClassName

if findwindow ==0:
    print("Couldn't get handle \n")
    exit(1)
else:
    print("Got handle!!")


lpdwProcessId = ctypes.c_ulong() #LPDWORD lpdwProcessId. LPDWORD is recognised in ctype as ctypes.c_ulong()
response = uhandle.GetWindowThreadProcessId(findwindow, ctypes.byref(lpdwProcessId))  #calling GetWindowThreadProcessId  ctypes.byref(lpdwProcessId) is used because it is a pointer to a variable that receives the process identifier as per microsoft documentation
if response == 0:
    print("Couldn't get PID!! Error Code: {0}".format(khandle.GetLastError()))  
    exit(1)
else:
    print("Got PID")

dwProcessId = lpdwProcessId

hProcess = khandle.OpenProcess(dwDesiredAccess, bInheritHandle,dwProcessId)
if hProcess <= 0:
    print("Couldn't grab handle")
    exit(1)
else:
    print("Got Handle")

uExitcode = 0x1
response = khandle.TerminateProcess(hProcess,uExitcode)  #calling TerminateProcess. note that this is under Kernel32.dll

if response == 0:
    print("Couldn't terminate! {0}".format(khandle.GetLastError()))
else:
    print("Process killed!! \n")
